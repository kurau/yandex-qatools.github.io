---
layout: post
title:  "Jenkins и цепочка джоб во имя избавления от рутины"
date:   2013-11-28 00:20:22 +0400
author:
    name: Merkushev Kirill
    email: lanwen+blog@yandex.ru
    gravatar: 6ee51971263d8c9a1e70e1dac7418d36
categories: [jenkins]
tags: [ci, jenkins, jira]
comments: true
published: true
---

# ...или как при помощи дворецкого приготовить суп из змей, скорлупы и капельки кофе.

## Прежде чем готовить кастрюлю
Воскресный вечер, туманище за окном, а дома тепло и уют. Дело портило только пустое брюхо,
которое отчаяно хотелось наполнить чем-то съедобным. В холодильнике было найдено множество
недогрызенных ранее остатков колбасы, сыра, кетчупа и прочих компонентов, поотдельности
сложно усвояемых. Было решено сделать пиццу, как наиболее простой вариант «собрать всё вместе
и будет вкусно» за небольшое количество времени.

Примерно к концу поглощения кулинарного творения, вдруг пришло понимание, в каком ключе стоит
рассказать о том, как избавиться от противного ощущения в животе, когда дело доходит до
очередного момента сборки пакета.

## Нам потребуется

1. **Дворецкий**. Дворецкого зовут [Jenkins][1]. *Jenkins* - это свободный продукт, с
огромным и развитым коммьюнити. Много рассказывать про него не буду, так как общей информации про него более
чем достаточно. В двух словах - это CI сервер, с плагинной архитектурой,
который благодаря им, умеет делать почти всё. Если чего то еще не умеет - значит просто никто
не заставлял его готовить суп вроде нашего, и просто-напросто не добавил своих плагинчиков в
коллекцию. О необходимых плагинах, я расскажу в процессе готовки.
2. **Скорлупа**. Тут речь идет о *shell-скриптах*. Ничего сложного - азы. **awk**, **grep**,
**sed**... 
3. **Змеи**. Самым простым способом быстрого прототипирования для нас оказался Python.
Дженкинс - это java продукт, и плагины для него пишутся на java. Но разработка плагина без
особой тренировки - это сложный процесс, и о нем обязательно будут статьи позже (когда
научимся сами ^_^). На питоне же, оказалось довольно быстро поднять черновую реализацию
любого функционала, который существующие плагины решить не смогли.
4. **Кофе**. По причине, указанной выше, приглядности и легкости конфигурации составных
частей отдельных шагов, питоновским скриптам не догнать плагины. Кроме того, бывает масса
плагинов, реализующих 95% функций. А тебе нужно лишь оставшиеся 5% - тогда гораздо легче
подпилить существующий плагин. Благо это опенсорс и все доступно. Конечно, бывают и случаи,
когда плагины содержат баги (да-да, их тоже пишут люди). Здесь уж приходится вооружаться
дебаггером и править код. Можно конечно просто завести issue и ждать фикса, но тогда решение
этой проблемы может затянуться, а мы же хотим быстрое решение? Да к тому же контрибьют - это
отличный шанс потренироваться в написании тестиков к чужому коду и получить славу и известность. 

## Разжигаем огонь, наливаем воду

Сперва, нужно определиться со структурой. Очевидно, что когда делаешь много действий, нужно закладывать запас
гибкости в конструкцию. Каждую толику работы нужно совершать отдельно и независимо. Тогда в случае поломок будет всегда
легко определить, где течь, и что нужно делать чтобы ее устранить.

> #### Хозяйке на заметку: 
>
> Если ваш дворецкий уже делает много-много всего, стоит присмотреться к плагинам,
организующим внешний вид ваших джоб. Мы использовали плагин [Nested View][2].
После создания, он предлагает добавить в себя другие, более простые (или более сложные) виды.
Клацаем по ссылке сбоку «*Новый вид*» и добавляем другие виды. 
В конце концов, можно получить аккуратную разбивку по папкам: 
>
> ![вид по папочкам - nested view][3]


У нас, для простоты описания, будет 4 *джобы* (в терминах jenkins). Первая будет собирать
пакет, вторая ставить его на машинку, третья запускать тесты, четвертая - информировать обо
всем окружающих. При этом все будут идти последовательно, кроме четвертой, которая будет
инициироваться каждой.

{% highlight bash %}
build-pack
|     └── notify-by-tracker 
install-pack
|     └── notify-by-tracker
run-tests
      └── notify-by-tracker
{% endhighlight %}

## Рубим скорлупу 

### Сборка
Сборка пакета - это вообще отдельная тема, почти уникальная для каждой команды разработки.
Зависит это не только от языка разработки, но и от конечного потребителя. Эту джобу
предлагается настроить самостоятельно. Стоит заметить, что в нашем варианте цепочки каждый
собираемый пакет будет устанавливаться на машинку и обстреливаться внешними интеграционными
тестами. Этот момент нужно учесть, если сборка у вас покоммитная. 

Добавим только на этом этапе [Description Setter Plugin][4] & [Build Name Setter Plugin][5].
Настройка каждого проста до безобразия, но имеет свои нюансы. Например, первый, для
дескрипшена - разделяет описание для успешного и неуспешного билда. Эта настройка скрывается
под кнопкой «*Расширенные*». Думаю с регулярными выражениями проблем возникнуть не должно - в
помощи есть пример. Искать сами настройки стоит в пост-билд степах.

> **Вопрос к зрителям:** Я на самом деле не понял как работать с мультизначениями в регулярке - если у кого то получится
реализовать, скиньте пример

Второй же, использует не просто переменные окружения, а так называемые [токены][6]. При этом
переменные окружения в виде этих токенов выглядят примерно так: `${ENV,var="VARIABLENAME"}` - подробнее, в справке к полю ввода.

Нам так же потребуется [Publish Over SSH Plugin][7]. С его помощью в конце выполнения джобы,
полученный артифакт с собранным пакетом мы зальем в репозиторий, где по крону сканируется
наличие новых пакетов, после чего пересобирается индекс. Настройка серверов - в общей
конфигурации Jenkins. Настройка места заливки - в post-build шагах.

### Установка
Это с одной стороны самая легкая в настройке джоба, с другой - одна из самых сложных.
Мы используем **red hat** и **yum**. Для дебиана процесс может несколько отличаться, но не
слишком кардинально.

Это параметризованная задача, с входным параметром - именем пакета для установки и
установленной галочкой (указав тестовую машинку)
>Restrict where this project can be run

Первый шаг - ожидание появления пакета в репозитории. Решение костыльное, и будет скоро
переделано.

{% highlight bash %}
WAIT_TIME=120
sudo yum list $METAPACKAGE_NAME 2>&1 | grep Error && (echo 'sleep'; sleep $WAIT_TIME; sudo yum clean metadata;) ||  echo 'Pack ok'
{% endhighlight %}

Здесь мы ищем в репозитории переданный пак, и если не находим - ждем 120 секунд (время
обновления кроном репозитория). После чего чистим кеш юма и пробуем еще раз.

Следующий шаг - простое `sudo yum install -y $METAPACKAGE_NAME`

> #### Хозяйке на заметку:
>Тут мы наивно предположили, что все зависимости всегда будут иметь возрастающую версию, и
будут четко указаны в пакете, потому как yum не умеет корректно решать конфликты и приходится
выкручиваться. Вариантов выкрутиться - несколько. Наиболее простой - удалять все что может
помешать. А потом заново ставить. Вариант более продвинутый - использовать виртуализацию и
поднимать машинку из конкретного чистого снепшота. 
В процессе борьбы с зависимостями пакетов вполне может помочь [Ansible][8]. 




## Чистим змею

### Запуск тестов
Так вышло, что тесты у нас крутятся отдельно, а их запускалка имеет REST-API. Вообще говоря,
тут вполне можно пускать например вебные тесты на селениум-гриде.

В параметрах нам потребуется адрес машинки (чтобы его легко можно было сменить).

Именно здесь, из-за наличия рестового апи у нас полный простор для творчества. Для быстрого
старта был написан питоновский скрипт, который и совершает манипуляции с апи + пишет в консоль текущее состояние.

Весь код я приводить не буду, укажу только подводные камни, на которые мы напоролись.
Начало скрипта выглядит так:

{% highlight python %}
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import httplib
import json
import time
{% endhighlight %}

Нам потребовалось обновить питон на конечной машинке, потому что тот, что стоял изначально не
обладал необходимым набором библиотек. Еще одна непрятная особенность - вывод русских
символов и сразу. Для этого пришлось обзавестись функцией:

{% highlight python %}
def printWithFlush(str):
    if isinstance(str, unicode):
        str = str.encode('utf-8')
    print str
    sys.stdout.flush()
    
{% endhighlight %}

Без такого способа печати, скрипт сначала накапливал буфер, а потом выплевывал все разом в
консоль (а нам то интересно тотчас узнавать что случилось). При этом на русских символах жалобно скулил и ничего дальше не делал.

У нас в планах написать полноценный плагин, который будет в дальнейшем этим заведовать вместо питона. 

## Завариваем кофе
Это пожалуй самая интересная часть из всего что пришлось делать. Ведь
*сборка-установка-запуск тестов* это обычное дело. Хочется же большего - уведомляшки. Чтобы
нажал на кнопку сборки - и ушел в код. А очнулся только когда на почту нотификация от трекера
упадет, мол - готово, хозяин. 

Как трекер мы используем Jira, и под него есть даже специальный плагин, который мне однажды
пришлось слегка допиливать, чтобы он умел комментировать без изменения воркфлоу. Кошелев
Артем уже [писал об этом][9]. В джобе добавилось лишь преобразование привычного
разработчикам перечисления тикетов через пробел в формат JQL при помощи *awk* и *sed*:

{% highlight bash %}
#Преобразует 'TICKET-1 TICKET-2' в 'id in (TICKET-1, TICKET-2)'
TASK=$(echo ${jiraTask} | sed -e 's/ /, /g' | awk '{ print "TASK_JQL=id in (" $0 ")" }')
echo $TASK >> jira.properties
{% endhighlight %}

И дальнейшего импорта этой переменной в переменные окружения при помощи [EnvInject Plugin][10] (по его настройке есть
даже картинки на его страничке).

Эта джоба проста и занимается только тем, что отправляет в трекер то, о чём другие ее
попросили. Т.е. формируем готовый комментарий мы в исходной задаче, а эту лишь дергаем,
просто прокидывая то что нужно. Ну и не забываем выставлять дескрипшен, перечисляя таски, в которых отписались.

Аналогичным же образом, можно добавить уведомление по Jabber протоколу - [Jabber Plugin][11] +
[Instant Messaging Plugin][12] (они работают только в паре). Правда беглый взгляд на jabber-плагин показал, что тот
умеет отправлять только билд-статусы, но не произвольный текст. Но это же опенсорс, и нужное легко реализовать! Тем
более в уже готовом плагине.


>#### Хозяйке на заметку:
> Открою маленький секрет - писать свой плагин, чтобы использовать java в нужном месте необязательно. Есть отличное
средство: **maven**! А точнее [Exec Maven Plugin][13]. Код пишется на java в *main* функции.
Коммитится в git (вы же не используете svn, правда?). Далее в джобе просто чекаутим репо, и
делаем цель Maven верхнего уровня - `clean compile exec:java`. Например так, я сделал сравнивалку пакетов на разных
машинах с прямым комментированием в Jira, переводом тикета на нужного человека и добавлением в CC - добавлять такое в
плагин показалось гораздо дольше и сложнее, чем сделать узкоспециальную задачу прям так.

> Кстати настройки exec-плагина для подобного запуска:
{% highlight xml %}
    <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>1.2.1</version>
        <executions>
            <execution>
                <goals>
                    <goal>java</goal>
                </goals>
            </execution>
        </executions>
        <configuration>
            <mainClass>ru.yandex.jenkins.MainExec</mainClass>
        </configuration>
    </plugin>
{% endhighlight %}

## Смешиваем ингридиенты

Вся цепочка на данном этапе самостоятельно выполняться не начнет. Пока это лишь отдельный набор джоб. Тут в дело
вступает [Parameterized Trigger Plugin][14]. Именно он - тот соус, что заставляет работать всю нашу систему как единое целое.

То как триггерится другая задача гибко настраивается. Я использовал в основном три вида передаваемых параметров.
Всегда - **Current Build Parameters**, чтобы насквозь из первой джобы пробрасывать тикеты Jira.
И **Predefined parameters**, либо **Parameters from properties file**. Предопределенные
параметры сами выглядят как проперти-файл, а параметры из проперти файла для тех случаев,
когда тот создавался, например, из питоновского скрипта - для передачи дальше.

> **Обратите внимание** - переменные, которые были заинжекчены при помощи *EnvInject Plugin* не передаются
вместе с *Current Build Parameters*. Так же, переменные билда перетираются переменными из файла и предопределенными
параметрами. (Хотя это может зависеть от порядка, определенного в триггере - тут стоит потестить).

Соответственно дополнительно выбраны условия - триггерить если сборка успешная, и не триггерить, если указанный файл
пропертей отстутствует.

### Недосолено

С этим плагином тоже вышло не очень круто с кириллицей - на момент версии *2.21* - плагин использует *java 1.5*, в
которой проперти читаются только в кодировке *Latin 1*. Что подразумевает под собой юникод-эскейпинг всего, что не
латинница. Соответственно простая кириллица превращается в нечто нечитаемое. Пока ждем принятия [пулл реквеста][15],
где я попытался это исправить.


## Варим, подаем к столу

Помимо оптимизации самих джоб на предмет собственных плагинов, у нас еще широкие планы отдать
в группу установки-запуска тестов еще несколько машин, чтобы полностью освободить наших
тестировщиков от установки пакета на стенд вручную и запуска тестов. Чтобы только отчеты смотреть.

Хочу добавить, что это реально удобно. И действительно может работать. На приготовление
такого супа было потрачено около двух полных дней с учетом написания всех скриптов для
поддержки работы, и ловли мелких багов, а так же формирования вида комментариев для Jira. Экономит же это примерно по
полчаса каждому разработчику на каждом пакете. Несложно посчитать как скоро потраченное время окупится. Притом что
готовится это проще пиццы на голодный желудок :)

  [1]: http://jenkins-ci.org/
  [2]: https://wiki.jenkins-ci.org/display/JENKINS/Nested+View+Plugin
  [3]: http://img-fotki.yandex.ru/get/9307/27441075.0/0_ebe23_7d26af5_orig
  [4]: https://wiki.jenkins-ci.org/display/JENKINS/Description+Setter+Plugin
  [5]: https://wiki.jenkins-ci.org/display/JENKINS/Build+Name+Setter+Plugin
  [6]: https://wiki.jenkins-ci.org/display/JENKINS/Token+Macro+Plugin
  [7]: https://wiki.jenkins-ci.org/display/JENKINS/Publish+Over+SSH+Plugin
  [8]: http://www.ansibleworks.com/docs/#the-basics
  [9]: http://artkoshelev.github.io/posts/jira-jenkins-plugin/
  [10]: https://wiki.jenkins-ci.org/display/JENKINS/EnvInject+Plugin
  [11]: https://wiki.jenkins-ci.org/display/JENKINS/Jabber+Plugin
  [12]: https://wiki.jenkins-ci.org/display/JENKINS/Instant+Messaging+Plugin
  [13]: http://mojo.codehaus.org/exec-maven-plugin/
  [14]: https://wiki.jenkins-ci.org/display/JENKINS/Parameterized+Trigger+Plugin
  [15]: https://github.com/jenkinsci/parameterized-trigger-plugin/pull/53