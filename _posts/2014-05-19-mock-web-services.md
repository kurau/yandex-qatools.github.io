---
layout: post
title:  "Сам себе web-сервис овер SSH"
date:   2014-05-19 19:12:22 +0400
author:
    name: Merkushev Kirill
    email: lanwen+blog@yandex.ru
    gravatar: 6ee51971263d8c9a1e70e1dac7418d36
categories: [mock]
tags: [mock, ssh]
comments: true
published: true
---

# ... или как замокать сервис, на порту удаленной машины, подняв его где угодно

## Far far away...

В далеком царстве, предалеком государстве жили и тужили тестировщики. И был у них зверь страшный, с именем заморским. Tcpdumpом его кликали.

И приносили тестировщикам каждую неделю жертву новую. Сервис жертвой этой был. Да необычный сервис, а с коллбэком.

Принося сервис новый, клич разработчики пускали по полям гулять: "Вы же тестировщики!" - восклицали они,
 - "Спустите tcpdump свой, на колбэки эти треклятыя!" - просили они. 

<del>Забросил Старик невод первый раз...</del> Запускали tcpdump тестировщики, да грепали в брюхе его необъятном крохи магические...
Нагрепанное бережно собирали, да парсили бедные. С трудом превеликим. Но некуда было им деваться, жертву перемолоть требовалось...

### Вы сказали ssh?

Казалось бы, не такая уж и грустная сказка. Пока не задумаешься о том, что нужно каждый релиз сервиса лезть в tcpdump и 
просеивать горы трафика! Становится мучительно горько, скучно и тяжело. 

Выход - автоматизируем. Берем [библиотечку для работы по SSH][ssh-ganymed], 
подключаемся к серверу, запускаем tcpdump и ловим все что можем в файлик. 
После теста киляем процесс и грепаем в файлике что нужно. Делали так? Нет? И не нужно!

### Почему не нужно?

- Работа с парсингом больших строк - это всегда много специфического кода, который сложно поддерживать.
- Парсинг HTTP сообщений уже давно сделан в сотнях библиотек. Зачем делать сто первую?
- Вы не сможете ничего распарсить впринципе, если общение идет по HTTPS.
- Как-то придется отфильтровывать тучи служебного мусора.

## Начнем сначала

Так как речь идет о тестировании - скорее всего, у нас есть все возможности не просто поставить сеточку в виде tcpdump,
 но и подменить один из сервисов целиком. Для таких целей есть замечательная библиотека [WireMock][wiremock]. Ее код можно посмотреть 
 на [GitHub-странице проекта][wiremock-github]. Суть ее в том, что поднимается web-сервис, с хорошим REST-api, 
 который можно настроить почти произвольным образом. 
 
 Тут и произвольные статус коды, и произвольное содержимое, 
 и проксирование запроса в реальные сервисы с возможностью сохранить ответы и отсылать их затем самостоятельно. Особо стоит отметить 
 возможность воссоздать негативное поведение - таймауты, обрывы связи, невалидные ответы. Красота! Библиотека при этом может 
 работать и как самостоятельный jar, и как WAR, который можно загрузить в Jetty, Tomcat... И самое главное: эту библиотеку 
 можно использовать прямо в тестах как рулу!
 
### Поднимаем фейк-сервис у себя

Итак, как и написано в гайде на странице библиотеки, создаем рулу:
{% highlight java %}
@Rule
public WireMockRule wiremock = new WireMockRule(LOCAL_MOCKED_PORT);
{% endhighlight %}

И включаем эмуляцию сервиса:

{% highlight java %}
@Test
public void shouldSend3Callbacks() throws Exception {
    stubFor(any(urlMatching(".*")).willReturn(aResponse()
                .withStatus(HttpStatus.OK_200).withBody("OK")));
                
    // Далее делаем так чтобы к нам пришел запрос и проверяем что такое приехало
    
    verify(3, postRequestedFor(urlMatching(".*callback.*"))
                 .withRequestBody(matching("^status=.*")));
}
{% endhighlight %}


### Говорим тестируемому - "Теперь ходи к нам!"

Осталась одна сложность - заставить удаленный сервис ходить в наш фейковый. Вот тут вспоминаем о такой штуке как 
порт-форвардинг. Нам потребуется REMOTE (который с ключом `-R`). Подробнее о том, что такое порт-форвардинг, 
я расскажу чуть позже.

> Если в двух словах, то это прокидывание трубы через ssh соединение от порта на удаленной машине, до порта на локальной. 
Хороший мануал можно найти на [www.debianadmin.com][port-forwarding]

Сейчас же, мы займемся самым верхним уровнем - интерфейсом рулы. Она позволит прокинуть связь 
`хост_удаленной_машины:порт -> ssh -> хост_машины_где_фейк_сервис:его_порт`.

### Делаем рулу порт-форвардинга

Вспоминаем про библиотеку [Ganymed SSH2][ssh-ganymed]. Подключаем ее, используя мавен: 
{% highlight xml %}
<!--https://code.google.com/p/ganymed-ssh-2/-->
<dependency>
   <groupId>ch.ethz.ganymed</groupId>
   <artifactId>ganymed-ssh2</artifactId>
   <version>${last-ganymed-ssh-ver}</version>
</dependency>
{% endhighlight %}

Открываем [пример][example-port-forwarding], использующий эту библиотеку для поднятия порт-форвардинга. 
Понимаем, что нам нужно 4 параметра. Будем считать, что тестируемый разговаривает через свой локальный порт, 
поэтому `хост_удаленной_машины` приравняем к `127.0.0.1`.

Остаётся 3 параметра, которые требуется указывать:
{% highlight java %}
@Rule
public SshRemotePortForwardingRule forward = onRemoteHost(props().serviceURI())
          .whenRemoteUsesPort(BIND_PORT_ON_REMOTE)
          .forwardToLocal().withForwardToPort(LOCAL_MOCKED_PORT);
{% endhighlight %}

Здесь, `.forwardToLocal()` это: 

{% highlight java %}
public SshRemotePortForwardingRule forwardToLocal() {
    try {
        hostToForward = getLocalHost().getHostAddress();
    } catch (UnknownHostException e) {
        throw new RuntimeException("Can't get local host", e);
    }
    return this;
}
{% endhighlight %}

Рулу удобно делать как наследника `ExternalResource`, переопределив `before()` для авторизации и поднятия порт-форвардинга, 
а `after()` для закрытия проброски порта и соединения.

Само соединение должно выглядеть примерно так:

{% highlight java %}
logger.info(format("Try to create port forwarding: `ssh %s -l %s -f -N -R %s:%s:%s:%s`",
                connection.getHostname(), SSH_LOGIN,
                hostOnRemote, portOnRemote, hostToForward, portToForward
        ));
connection.requestRemotePortForwarding(hostOnRemote, portOnRemote, hostToForward, portToForward);
{% endhighlight %}

## Сказка быль, да в ней намёк

Добавив такую рулу, при включенном порт-форвардинге мы можем локально получать и анализировать все, 
что придет на удаленной машине на указанный порт. WireMock при этом позволяет достать целиком все запросы по нужному условию и 
применить к ним привычные матчеры.

Но есть и ряд ограничений в таком подходе:

- Потребуется SSH доступ на машину.
- Порт-форвардинг должен быть на этой машине включен.
- Потребуется останавливать сервисы, если захочется повеситься на их порт, чтобы замокать его. 
  А это значит нужны права пользователю на остановку сервисов без пароля.
- В некоторых организациях нельзя пробрасывать порт без санкций администраторов.


[ssh-ganymed]: https://code.google.com/p/ganymed-ssh-2/
[wiremock]: http://wiremock.org/
[wiremock-github]: https://github.com/tomakehurst/wiremock
[port-forwarding]: http://www.debianadmin.com/howto-use-ssh-local-and-remote-port-forwarding.html
[example-port-forwarding]: https://code.google.com/p/ganymed-ssh-2/source/browse/trunk/examples/PortForwarding.java?r=2