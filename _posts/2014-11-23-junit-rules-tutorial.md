#...или жизненный уклад и основные обычаи автоматизатора 21го века (с примерами).

## JUnit
С фрэймворком модульного тестирования [http://junit.org/], мне кажется, знакомы все. 
Как видно из его описания, он направлен на создание "повторяемых" (repeatable) тестов. Что это значит?
Значит тесты, кторые мы написали, придётся ещё и поддерживать.
Поэтому в основную очередь стоит рассматривать данный инструмент как набор удобных механизмов, 
которые направлены на то, чтобы облегчить написание и дальнейшую поддержку наших тестов.
В данной статье мы остановимся подробней на механизме правил (Rules). 

## @Before -> @Test -> @After
Для логического деления теста на "до" и "после" (исторически для этих методов приняты 
специальные названия - "setUp" и "tearDown") используются специальные аннотации @Before и @After 
(начиная с JUnit 4.*), которые указывают, когда будет исполнятся тот или иной метод.  
Нарпимер, исполнив такой код
{% highlight java %}
public class SimpleTest {
    @Before
    public void before() {
        System.out.println("before");
    }
     
    @After
    public void after() {
        System.out.println("after");
    }
     
    @Test
    public void test() {
        System.out.println("test");
    }
}
{% endhighlight %}
мы получим следующий результат
>before
>test
>after

Нюансы:
* Может быть несколько методов (или не быть совсем) с аннотациями @Before и @After.
* Если в классе больше одного метода с одной из таких аннотаций - методы каждый раз будут 
выполняться в произвольном порядке.

Как уже было сказано, наличие аннтаций @Before и @After позволяет разделить тест на блоки:
* Подготовка: создание необходимых данных; обеспечение доступа к ресурсам (например DB);
* Тест: действия, необходимые для получения результата; проверка, что нужный результат достигнут;
* Завершение: очищение данных; освбождение занятых ресурсов;

Такой подход к написанию тестов делает их, во-первых, интуитивно понятными (так как мы можем отделить логику теста от 
остальных служебных действий), во-вторых, даёт возможность переиспользовать уже написанные модули.
Чтобы проиллюстрировать, возьмём предыдущий пример. Добавим туда второй тест, который по легенде нуждается в 
таких же начальных данных (метод before):
{% highlight java %}
public class SimpleTest {
    @Before
    public void before() {
        System.out.println("before");
    }
     
    @After
    public void after() {
        System.out.println("after");
    }
     
    @Test
    public void test() {
        System.out.println("test");
    }
    
    @Test
    public void secondTest() {
        System.out.println("second test");
    }
}
{% endhighlight %}
Результат выполнения:
>before
>test
>after
>before
>second test
>after

Важно отметить, что метод с аннотацией @After будет выполняться всегда, вне зависимости от того, как прошёл тест.
С этой точки зрения всё получается строго линейным. На самом деле JUnit позволяет перехватывать и обрабатывать 
намного больше событий, что позволяет сделать логику теста более гибкой.

Для этого предлагается использовать специальный механизм правил (Rules).

##Rules



## TemporaryFolder Rule
Позволяет создавать файлы и папки которые гарантированно удалятся посл выполнения теста
## ExternalResource Rules
## ErrorCollector Rule
## Verifier Rule
## TestWatchman/TestWatcher Rules
